<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D 图片查看器</title>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background-color: #1a1a1a;
        }
        #modelType {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 100;
            padding: 10px 15px;
            border-radius: 8px;
            border: 2px solid #4CAF50;
            background: rgba(30, 30, 30, 0.8);
            color: white;
            font-size: 16px;
            cursor: pointer;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            color: white;
            background: rgba(0, 0, 0, 0.85);
            padding: 25px 40px;
            border-radius: 12px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }
        #loading-spinner {
            border: 5px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top: 5px solid #4CAF50;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        #instructions {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            background: rgba(0, 0, 0, 0.6);
            padding: 12px 20px;
            border-radius: 8px;
            z-index: 100;
            text-align: center;
            font-size: 18px;
            backdrop-filter: blur(5px);
        }
        #status {
            position: absolute;
            top: 70px;
            left: 50%;
            transform: translateX(-50%);
            color: #FF9800;
            z-index: 100;
            text-align: center;
            font-size: 16px;
        }
    </style>
</head>
<body>

<select id="modelType">
    <option value="plane">平面</option>
    <option value="cube">立方体</option>
    <option value="sphere">球体</option>
</select>

<div id="loading">
    <div id="loading-spinner"></div>
    <div>加载图片中...</div>
</div>

<div id="instructions">用手指拖动可以旋转模型</div>
<div id="status"> 等待图片加载...</div>

<script>
    // 全局变量
    let scene, camera, renderer, mesh;
    let modelType = 'plane';
    let isDragging = false;
    let previousMousePosition = { x: 0, y: 0 };
    let textureLoader = new THREE.TextureLoader();

    // 调试函数
    function debugLog(message) {
        console.log("[DEBUG] " + message);
        if (typeof AndroidInterface !== 'undefined' && typeof AndroidInterface.log === 'function') {
            AndroidInterface.log(message);
        }
    }

    // 更新状态
    function updateStatus(message) {
        const statusElement = document.getElementById('status');
        if (statusElement) {
            statusElement.textContent = message;
        }
    }

    // 初始化场景
    function init() {
        debugLog("初始化3D场景");
        updateStatus("初始化场景...");

        // 创建场景
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x121212);

        // 创建相机
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        resetCameraPosition();

        // 创建渲染器
        renderer = new THREE.WebGLRenderer({
            antialias: true,
            alpha: true
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // 添加光源
        addLights();

        // 添加事件监听器
        setupEventListeners();

        // 创建初始占位模型
        createPlaceholderModel();

        // 开始动画循环
        animate();

        // 显示初始状态
        updateStatus("场景初始化完成，等待图片加载");

        debugLog("3D场景初始化完成");
    }

    // 创建占位模型
    function createPlaceholderModel() {
        debugLog("创建占位模型");

        // 清除现有模型
        if (mesh) {
            scene.remove(mesh);
            mesh.geometry.dispose();
            mesh.material.dispose();
        }

        const geometry = new THREE.BoxGeometry(1, 1, 1);
        const material = new THREE.MeshBasicMaterial({
            color: 0x2196F3,
            wireframe: true
        });

        mesh = new THREE.Mesh(geometry, material);
        scene.add(mesh);

        debugLog("占位模型创建完成");
    }

    // 重置相机位置
    function resetCameraPosition() {
        debugLog("重置相机位置");

        switch(modelType) {
            case 'plane':
                camera.position.z = 5;
                break;
            case 'cube':
                camera.position.z = 7;
                break;
            case 'sphere':
                camera.position.z = 6;
                break;
            case 'torus':
                camera.position.z = 8;
                break;
            default:
                camera.position.z = 5;
        }

        camera.lookAt(0, 0, 0);
    }

    // 添加光源
    function addLights() {
        debugLog("添加光源");

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.9);
        directionalLight.position.set(1, 1, 1);
        scene.add(directionalLight);

        const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.5);
        directionalLight2.position.set(-1, -1, -1);
        scene.add(directionalLight2);

        const pointLight = new THREE.PointLight(0xffffff, 0.7);
        pointLight.position.set(0, 3, 2);
        scene.add(pointLight);
    }

    // 设置事件监听器
    function setupEventListeners() {
        debugLog("设置事件监听器");

        // 窗口大小调整
        window.addEventListener('resize', onWindowResize);

        // 模型类型选择
        document.getElementById('modelType').addEventListener('change', function() {
            modelType = this.value;
            debugLog("模型类型更改为: " + modelType);

            if (mesh && mesh.material.map) {
                loadModelWithTexture(mesh.material.map);
            } else {
                createPlaceholderModel();
            }
        });

        // 鼠标/触摸交互
<!--        renderer.domElement.addEventListener('mousedown', onMouseDown);-->
<!--        renderer.domElement.addEventListener('mousemove', onMouseMove);-->
<!--        renderer.domElement.addEventListener('mouseup', onMouseUp);-->
<!--        renderer.domElement.addEventListener('mouseleave', onMouseUp);-->

        renderer.domElement.addEventListener('touchstart', onTouchStart);
        renderer.domElement.addEventListener('touchmove', onTouchMove);
        renderer.domElement.addEventListener('touchend', onTouchEnd);
    }

    // 窗口大小调整处理
    function onWindowResize() {
        debugLog("窗口大小调整");

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

<!--    // 鼠标/触摸事件处理-->
<!--    function onMouseDown(event) {-->
<!--        isDragging = true;-->
<!--        previousMousePosition = {-->
<!--            x: event.clientX,-->
<!--            y: event.clientY-->
<!--        };-->
<!--    }-->

<!--    function onMouseMove(event) {-->
<!--        if (!isDragging || !mesh) return;-->

<!--        const deltaMove = {-->
<!--            x: event.clientX - previousMousePosition.x,-->
<!--            y: event.clientY - previousMousePosition.y-->
<!--        };-->

<!--        mesh.rotation.y += deltaMove.x * 0.01;-->
<!--        mesh.rotation.x += deltaMove.y * 0.01;-->

<!--        previousMousePosition = {-->
<!--            x: event.clientX,-->
<!--            y: event.clientY-->
<!--        };-->
<!--    }-->

<!--    function onMouseUp() {-->
<!--        isDragging = false;-->
<!--    }-->

    function onTouchStart(event) {
        if (event.touches.length === 1) {
            isDragging = true;
            previousMousePosition = {
                x: event.touches[0].clientX,
                y: event.touches[0].clientY
            };
            event.preventDefault();
        }
    }

    function onTouchMove(event) {
        if (!isDragging || !mesh || event.touches.length !== 1) return;

        const deltaMove = {
            x: event.touches[0].clientX - previousMousePosition.x,
            y: event.touches[0].clientY - previousMousePosition.y
        };

        mesh.rotation.y += deltaMove.x * 0.01;
        mesh.rotation.x += deltaMove.y * 0.01;

        previousMousePosition = {
            x: event.touches[0].clientX,
            y: event.touches[0].clientY
        };

        event.preventDefault();
    }

    function onTouchEnd() {
        isDragging = false;
    }

    // 动画循环
    function animate() {
        requestAnimationFrame(animate);

        // 如果不是拖动状态，自动旋转
        if (mesh && !isDragging) {
            mesh.rotation.y += 0.005;
        }

        renderer.render(scene, camera);
    }

    // 使用字节数组创建纹理
    function createTextureFromByteArray(byteArray) {
        debugLog("开始创建纹理");
        updateStatus("创建纹理中...");

        try {
            // 将字节数组转换为Blob
            const blob = new Blob([new Uint8Array(byteArray)], {type: 'image/png'});

            // 创建对象URL
            const imageUrl = URL.createObjectURL(blob);

            debugLog("图片对象URL创建成功");
            updateStatus("加载图片...");

            // 加载纹理
            textureLoader.load(
                imageUrl,
                function(texture) {
                    debugLog("纹理加载成功");
                    updateStatus("应用纹理...");

                    loadModelWithTexture(texture);

                    // 释放对象URL
                    URL.revokeObjectURL(imageUrl);

                    // 隐藏加载指示器
                    document.getElementById('loading').style.display = 'none';
                    updateStatus("图片加载完成");
                },
                undefined,
                function(error) {
                    console.error('加载纹理失败:', error);
                    updateStatus("纹理加载失败");
                    document.getElementById('loading').style.display = 'none';
                    alert('加载纹理失败: ' + error.message);

                    // 释放对象URL
                    URL.revokeObjectURL(imageUrl);
                }
            );
        } catch (error) {
            console.error('创建纹理时出错:', error);
            updateStatus("创建纹理失败");
            document.getElementById('loading').style.display = 'none';
            alert('创建纹理失败: ' + error.message);
        }
    }

    // 使用纹理加载模型
    function loadModelWithTexture(texture) {
        debugLog("使用纹理加载模型");
        updateStatus("创建3D模型...");

        // 清除现有模型
        if (mesh) {
            scene.remove(mesh);
            mesh.geometry.dispose();
            mesh.material.dispose();
        }

        let geometry;
        switch (modelType) {
            case 'plane':
                geometry = new THREE.PlaneGeometry(4, 3);
                camera.position.z = 5;
                break;
            case 'cube':
                geometry = new THREE.BoxGeometry(2, 2, 2);
                camera.position.z = 7;
                break;
            case 'sphere':
                geometry = new THREE.SphereGeometry(1.5, 32, 32);
                camera.position.z = 6;
                break;
            case 'torus':
                geometry = new THREE.TorusGeometry(1.5, 0.5, 16, 100);
                camera.position.z = 8;
                break;
            default:
                geometry = new THREE.PlaneGeometry(4, 3);
                camera.position.z = 5;
        }

        const material = new THREE.MeshStandardMaterial({
            map: texture,
            roughness: 0.3,
            metalness: 0.2
        });

        mesh = new THREE.Mesh(geometry, material);
        scene.add(mesh);

        resetCameraPosition();

        debugLog("模型加载完成");
        updateStatus("3D模型已就绪");
    }

    // 全局函数用于接收图片数据 这个方法应该是核心的
    window.loadImageFromAndroid = function(byteArray) {
        debugLog("接收到来自Android的图片数据");
        document.getElementById('loading').style.display = 'flex';
        updateStatus("处理图片数据...");

        try {
            debugLog("字节数组长度: " + byteArray.length);

            if (!byteArray || byteArray.length === 0) {
                throw new Error("接收到的字节数组为空");
            }

            createTextureFromByteArray(byteArray);
        } catch (error) {
            console.error('处理图片数据时出错:', error);
            updateStatus("处理图片失败");
            document.getElementById('loading').style.display = 'none';
            alert('处理图片数据失败: ' + error.message);
        }
    };

    // 初始化应用
    window.onload = function() {
        debugLog("页面加载完成");
        init();
    };
</script>
</body>
</html>